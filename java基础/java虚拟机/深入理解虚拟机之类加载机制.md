## 深入理解虚拟机之类加载机制

https://juejin.im/post/5a1d5f286fb9a045132a7100

**本节常见面试题（推荐带着问题阅读，问题答案在文中都有提到）：**

简单说说类加载过程，里面执行了哪些操作？

对类加载器有了解吗？

什么是双亲委派模型？

双亲委派模型的工作过程以及使用它的好处。

## 1 概述

上一节我们已经知道了类文件结构，在class文件中描述的各种信息最终都需要加载到虚拟机中之后才能运行和使用。

那么虚拟机是如加载这些class文件呢？class文件中的信息进入到虚拟机后会发生什么变化呢？

### 1.1 虚拟机类加载机制的概念

虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化。最终形成可以被虚拟机最直接使用的java类型的过程就是虚拟机的类加载机制。

### 1.2 Java语言的动态加载和动态连接

另外需要注意的很重要的一点是：**java语言中类型的加载连接以及初始化过程都是在程序运行期间完成的**，这种策略虽然会使类加载时稍微增加一些性能开销，但是会为java应用程序提供高度的**灵活性**。java里天生就可以动态扩展语言特性就是依赖运行期间动态加载和动态连接这个特点实现的。比如，如果编写一个面向接口的程序，可以等到运行时再指定其具体实现类。

## 2 类加载时机

类从被加载到虚拟机内存到卸出内存为止，它的整个生命周期包括：

![img](https://mmbiz.qpic.cn/mmbiz_png/hvUCbRic69sAxRovHTCH3yyW1vpic22WVibSBjZicRXsFogpbuwicqugUaxFaIBQnXxwibQ0XTicKxxCVfb0L8sejJkjw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，而解析过程不一定，它可以出现再初始化之后执行。**

我们思考一下那么**什么时候需要开始类加载的第一个阶段：加载？**

​	Java虚拟机规范并没有约束这一点，但是却规定了类必须进行**初始化**的5种情况

​	**虚拟机规范严格规定了有且只有五种情况必须立即对类进行“初始化”：**

- 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候(被final修饰、已在编译期把结果放入常量池的静态字段除外)，以及调用一个类的静态方法的时候。
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。
- 当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类；
- 使用Jdk1.7动态语言支持的时候的一些情况。

**而对于接口，当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口时（如引用父接口中定义的常量）才会初始化**

这5类称为对一个类的主动调用。**所有引用类的方式都不会触发初始化，称为被动引用，下面是3个被动引用例子：**

​	**①通过子类引用父类静态字段，不会导致子类初始化；**

​	**②通过数组定义引用类，不会触发此类的初始化；**

​	**③常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用定义常量的类，因此不会触发定义常量的类的初始化**

## 3 类加载过程

下面我们详细的说一下java虚拟机中类加载的全过程：**加载**、**验证**、**准备**、**解析**和**初始化**这5个阶段锁执行的具体工作。

**“加载”** 是 **“类加载”** 过程的一个阶段，切不可将二者混淆。

**加载阶段由三个基本动作组成：**

1) 通过类型的完全限定名，产生一个代表该类型的二进制数据流（根本没有指明从哪里获取、怎样获取，可以说一个非常开放的平台了）

2) 解析这个二进制数据流为方法区内的运行时数据结构

3) 创建一个表示该类型的java.lang.Class类的实例，作为方法区这个类的各种数据的访问入口。

**通过类型的完全限定名，产生一个代表该类型的二进制数据流的几种常见形式：**

- 从zip包中读取，成为日后JAR、EAR、WAR格式的基础；

- 从网络中获取，这种场景最典型的应用就是Applet;

- 运行时计算生成，这种场景最常用的就是动态代理技术了；

- 由其他文件生成，比如我们的JSP；

  **注意：** 非数组类加载阶段既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成。（即重写一个类加载器的loadClass（）方法）

### 3.2 验证

验证是连接阶段的第一步，这一阶段的目的是**为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全**

虚拟机如果不检查输入的字节流，并对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。这个阶段是否严谨，直接决定了java虚拟机是否能承受恶意代码的攻击。

从整体上看，验证阶段大致上会完成4个阶段的校验工作：**文件格式、元数据、字节码、符号引用**。

### 3.2.1 文件格式验证

验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。这个阶段验证是基于二进制字节流进行的，只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面的3个阶段的全部是基于方法区的存储结构进行的，不会再直接操作字节流。	

主要验证点：

- 是否以魔数`0xCAFEBABE`开头
- 主次版本号是否在当前虚拟机处理范围之内
- 常量池的常量是否有不被支持的类型 (检查常量tag标志)
- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
- CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据
- Class文件中各个部分及文件本身是否有被删除的或者附加的其他信息
  ...

实际上验证的不仅仅是这些，关于Class文件格式可以参考我的[深入理解JVM类文件格式](https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5a0d3ea35188253d681723f0)，这阶段的验证是基于二进制字节流的，只有通过文件格式验证后，字节流才会进入内存的方法区中进行存储。

#### 3.2.2 元数据验证

**该阶段对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，目的是保证不存在不符合Java语言规范的元数据信息**。

主要验证点：

- 该类是否有父类（只有Object对象没有父类，其余都有）
- 该类是否继承了不允许被继承的类（被final修饰的类）
- 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
- 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，出现不符合规则的方法重载，例如方法参数都一致，但是返回值类型却不同）
  ...

#### 3.2.3 字节码验证

**该阶段主要工作时进行数据流和控制流分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。** 例如，保证跳转指令不会跳转到方法体以外的字节码指令上、保证方法体中的类型转换是有效的等等。

主要有：

- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似的情况：操作数栈里的一个int数据，但是使用时却当做long类型加载到本地变量中
- 保证跳转不会跳到方法体以外的字节码指令上
- 保证方法体内的类型转换是合法的。例如子类赋值给父类是合法的，但是父类赋值给子类或者其它毫无继承关系的类型，则是不合法的。

由于数据流校验的高复杂性，耗时较大，所以JDK1.6之后，在Javac中引入一项优化方法（可以通过参数关闭）：在方法体的Code属性的属性表中增加一项“StackMapTable”属性，该属性描述了方法体中所有基本块开始时本地变量表和操作栈应有的状态，从而将字节码验证的类型推导转变为类型检查从而节省一些时间。

**注意：** 如果一个方法体通过了字节码验证，也不能说明其一定是安全的，因为校验程序逻辑无法做到绝对精确。

#### 3.2.4 符号引用验证

**最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证的目的是确保解析动作能正常执行。**

**验证的内容主要有：**

- 符号引用中通过字符串描述的全限定名是否能找到对应的类；
- 在指定类中是否存在符号方法的字段描述及简单名称所描述的方法和字段；
- 符号引用中的类、字段和方法的访问性（private、protected、public、default）是否可被当前类访问。

### 3.3 准备

**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。**（备注：这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中）。

**初始值通常是数据类型的零值：**

对于：public static int value = 123;，那么变量value在准备阶段过后的初始值为0而不是123，这时候尚未开始执行任何java方法，把value赋值为123的动作将在初始化阶段才会被执行。

**一些特殊情况：**

对于：public static final int value = 123;编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

**基本数据类型的零值：**

![img](https://mmbiz.qpic.cn/mmbiz_png/hvUCbRic69sAxRovHTCH3yyW1vpic22WVibjy2myhv92Kg9yqMvfNYMeWUiaZZrxLKNnmH5RcZskwjGmT2KWf49Ahw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 3.4 解析

**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。**

**那么符号引用与直接引用有什么关联呢？**

#### 3.4.1 看两者的概念。

**符号引用(Symbolic References)：** 符号引用以一组符号来描述所引用的目标，符号可以是符合约定的任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。

**直接引用（Direct References）:** 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局相关，引用的目标必定已经在内存中存在。

虚拟机规范没有规定解析阶段发生的具体时间，虚拟机实现可以根据需要来判断到底是在类被加载时解析还是等到一个符号引用将要被使用前才去解析。

#### 3.4.2 对解析结果进行缓存

同一符号引用进行多次解析请求是很常见的，除invokedynamic指令以外，虚拟机实现可以对第一次解析结果进行缓存，来避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个引用符号之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果 第一次解析失败，那么其他指令对这个符号的解析请求也应该收到相同的异常。

**由invokedynamic指令触发过的解析的符号引用，必须等到程序实际运行到这条指令的时候，解析动作才能进行。**

下面来看几种基本的解析：
**类与接口的解析**： 假设Java虚拟机在类D的方法体中引用了类N或者接口C，那么会执行下面步骤：

1. 如果C不是数组类型，D的定义类加载器被用来创建类N或者接口C。加载过程中出现任何异常，可以被认为是类和接口解析失败。
2. 如果C是数组类型，并且它的元素类型是引用类型。那么表示元素类型的类或接口的符号引用会通过递归调用来解析。
3. 检查C的访问权限，如果D对C没有访问权限，则会抛出`java.lang.IllegalAccessError`异常。

**字段解析**：
要解析一个未被解析过的字段符号引用，首先会对字段表内class_index项中索引的`CONSTANT_Class_info`符号引用进行解析，这边记不清的可以继续回顾[深入理解JVM类文件格式](https://link.juejin.im/?target=http%3A%2F%2Fwww.jianshu.com%2Fp%2F6950542b3e1f),也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段解析失败。如果解析完成，那将**这个字段所属的类或者接口**用C表示，虚拟机规范要求按照如下步骤对Ｃ进行后续字段的搜索。

1 . 如果C本身包含了简单名称和字段描述符都与目标相匹配的字段，则直接返回这个字段的直接引用，查找结束。
2 . 否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
3 . 再不然，如果C不是`java.lang.Object`的话，将会按照继承关系从下往上递归搜索其父类，如果在类中包含
了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
4 . 如果都没有，查找失败退出，抛出`java.lang.NoSuchFieldError`异常。如果返回了引用，还需要检查访问权限，如果没有访问权限，则会抛出`java.lang.IllegalAccessError`异常。

在实际的实现中，要求可能更严格，如果同一字段名在C的父类和接口中同时出现，编译器可能拒绝编译。

**类方法解析**
类方法解析也是先对类方法表中的class_index项中索引的方法所属的类或接口的符号引用进行解析。我们依然用C来代表解析出来的类，接下来虚拟机将按照下面步骤对C进行后续的类方法搜索。
1 . 首先检查方法引用的C是否为类或接口，如果是接口，那么方法引用就会抛出`IncompatibleClassChangeError`异常
2  .  方法引用过程中会检查C和它的父类中是否包含此方法，如果C中确实有一个方法与方法引用的指定名称相同，并且声明是签名多态方法（Signature  Polymorphic  Method）,那么方法的查找过程就被认为是成功的，所有方法描述符所提到的类也需要解析。对于C来说，没有必要使用方法引用指定的描述符来声明方法。
3 . 否则，如果C声明的方法与方法引用拥有同样的名称与描述符，那么方法查找也是成功。
4 . 如果C有父类的话，那么按照第2步的方法递归查找C的直接父类。
5 . 否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在相匹配的方法，说明类C时一个抽象类，查找结束，并且抛出`java.lang.AbstractMethodError`异常。

1. 否则，宣告方法失败，并且抛出`java.lang.NoSuchMethodError`。
   最后的最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，那么会抛出 `java.lang.IllegalAccessError`异常。

**接口方法解析**
接口方法也需要解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。
1 . 与类方法解析不同，如果在接口方法表中发现class_index对应的索引C是类而不是接口，直接抛出`java.lang.IncompatibleClassChangeError`异常。
2 . 否则，在接口C中查找是否有简单名称和描述符都与目标匹配的方法，如果有则直接返回这个方法的直接引用，查找结束。
3 . 否则，在接口C的父接口中递归查找，直到`java.lang.Object`类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
4 . 否则，宣告方法失败，抛出`java.lang.NoSuchMethodError`异常。

由于接口的方法默认都是public的，所以不存在访问权限问题，也就基本不会抛出`java.lang.IllegalAccessError`异常。

### 3.5 初始化

类初始化阶段是类加载的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码（或者说是字节码）。

在准备阶段，变量都被赋予了初始值，但是到了初始化阶段，所有变量还要按照用户编写的代码重新初始化。换一个角度，初始化阶段是执行类构造器`<clinit>()`方法的过程。

`<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static语句块)中的语句合并生成的，**编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问**。

~~~
public class Test {
  static {
    i=0;  //可以赋值
    System.out.print(i); //编译器会提示“非法向前引用”
  }
  static int i=1;
}
~~~

 `<clinit>()`方法与类的构造函数`<init>()`方法不同，它不需要显示地调用父类构造器，虚拟机会宝成在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`已经执行完毕，因此在虚拟机中第一个被执行的`<clinit>()`一定是`java.lang.Object`的。

也是由于`<clinit>()`执行的顺序，所以父类中的静态语句块优于子类的变量赋值操作，所以下面的代码段，B的值会是2。

~~~
static class Parent {
  public static int A=1;
  static {
    A=2;
  }
}

static class Sub extends Parent{
  public static int B=A;
}

public static void main(String[] args) {
  System.out.println(Sub.B);
}
~~~



`<clinit>()`方法对于类来说不是必须的，如果一个类中既没有静态语句块也没有静态变量赋值动作，那么编译器都不会为类生成`<clinit>()`方法。

接口中不能使用静态语句块，但是允许有变量初始化的赋值操作，因此接口与类一样都会生成`<clinit>()`方法，但是接口中的`<clinit>()`不需要先执行父类的，只有当父类中定义的变量使用时，父接口才会初始化。除此之外，**接口的实现类在初始化时也不会执行接口的`<clinit>()`方法**。

虚拟机会保证一个类的`<clinit>()`方法在多线程环境中能被正确的加锁、同步。如果多个线程初始化一个类，那么只有一个线程会去执行`<clinit>()`方法，其它线程都需要等待。

## 4 类加载器

### 4.1、类与类加载器

类加载的第一个阶段就需要**通过一个类的全限定名来获取描述此类的二进制字节流**，实现这个动作的模块就是类加载器。

类加载器虽然只是实现类的加载动作，但是在Java程序中的作用远不止于此。在Java中一个类的唯一性不仅仅是看类本身，还要看它的加载器。通俗地说：比较两个类是否**相等**，只有在两个类时由同一个类加载器加载的前提下才有意义，否则，即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同，两个类也不相等。

### 4.2 类加载器介绍

从Java虚拟机的角度分为两种不同的类加载器：**启动类加载器（Bootstrap ClassLoader）**和**其他类加载器**。其中启动类加载器，使用C++语言实现，是虚拟机自身的一部分；其余的类加载器都由Java语言实现，独立于虚拟机之外，并且全都继承自**java.lang.ClassLoader类**。（这里只限于HotSpot虚拟机）。

从Java开发人员的角度来看，绝大部分Java程序都会使用到以下3种系统提供的类加载器。

**启动类加载器(Bootstrap ClassLoader)**: 这个类将负责把`<JAVA_HOME>\lib\`目录中的，或者`-Xbootclasspath`参数指定的目录所指定的路径中的，并且是虚拟机识别的的类库加载到虚拟机内存中，如rt.jar，识别仅按照文件名识别，如果名字不符合，即使在这个目录下，也不会被加载。启动类加载器无法被java程序直接引，用户如果在编写自定义的类加载器时，如果需要把加载请求委托给引导类加载器，那么直接用null代替即可。

**扩展类加载器(Extension ClassLoader)**: 这个类加载器由`sun.misc.Launcher $ExtClassLoader`实现，它负责加载`<JAVA_HOME>\lib\ext`目录中的，或者被`java.ext.dirs`系统变量所指定的路径中的所有类库。

**应用程序加载类(Application ClassLoader)**: 这个类加载器是由`sun.misc.Launcher $App-ClassLoader`实现。该加载器是由ClassLoader的`getSystemClassLoader()`方法返回，所以一般称它为系统类加载器。一般它加载用户类路径(ClassPath)所指定的类库，开发者一般直接使用这个类加载器，如果没有定义自己的类加载器，那么这个应用程序加载类就是程序中默认的类加载器。

我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。

![类加载器](https://user-gold-cdn.xitu.io/2017/11/29/1600759606971ba6?imageView2/0/w/1280/h/960/ignore-error/1)

### 4.3 双亲委派模型

**双亲委派模型（Pattern Delegation Model）**,要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。这里父子关系通常是子类通过组合关系而不是继承关系来复用父加载器的代码。

**双亲委派模型的工作过程**：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成，每个层次的类加载器都是如此，因此最后所有的请求都会传递到顶层的启动类加载器中，只有当父加载器返回自己无法完成这个加载请求（即它的搜索范围内没有找到所需要的类），子加载器才会尝试去自己加载**。

> 使用双亲委派模型的好处呢？

使用双亲委派模型最直接的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，例如`jaba.lang.Object`类，它存放在`rt.jar`中，无论哪一个类加载器要加载这个类，最终都要委派给最上层的`boostrap ClassLoader`，所以Object类在程序的各种类加载器环境中都是同一个类。假如没有使用双亲委派模型，由各个类各自加载Object，那么系统里将会出现各种版本的Object类，导致整个系统的混乱。

下面我们从ClassLoader的源码来看看双亲委派模式：

1. 调用`findLoadedClass(String)`来检查类是否已经被加载；
2. 调用父类的`loadClass`方法，如果父类为空，就调用虚拟机内置的引导类加载器加载；
3. 调用`findClass(String)`来查找该类。

因为`loadClass`封装了双亲委派模型，所以在开发自己的类加载器时，Java标准提覆写`findClass()`方法。

检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。

如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。

如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的**findClass**方法来完成类加载。默认的findclass毛都不干，直接抛出ClassNotFound异常，所以我们自定义类加载器就要覆盖这个方法了。

loadClass在父加载器无法加载类的时候，就会调用我们自定义的类加载器中的findeClass函数，因此我们必须要在loadClass这个函数里面实现将一个指定类名称转换为Class对象.
如果是是读取一个指定的名称的类为字节数组的话，这很好办。但是如何将字节数组转为Class对象呢？很简单，Java提供了defineClass方法，通过这个方法，就可以把一个字节数组转为Class对象啦~

### 4.4 破坏双亲委派模型

双亲委派模型主要出现过3次较大规模“被破坏”的情况。

**第一次破坏**是因为类加载器和抽象类java.lang.ClassLoader在JDK1.0就存在的，而双亲委派模型在JDK1.2之后才被引入，为了兼容已经存在的用户自定义类加载器，引入双亲委派模型时做了一定的妥协：在java.lang.ClassLoader中引入了一个findClass()方法，在此之前，用户去继承java.lang.Classloader的唯一目的就是重写loadClass()方法。JDK1.2之后不提倡用户去覆盖loadClass()方法，而是把自己的类加载逻辑写到findClass()方法中，如果loadClass()方法中如果父类加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型规则的。

**第二次破坏**是因为模型自身的缺陷，现实中存在这样的场景：基础的类加载器需要求调用用户的代码，而基础的类加载器可能不认识用户的代码。为此，Java设计团队引入的设计时“线程上下文类加载器（Thread Context ClassLoader）”。这样可以通过父类加载器请求子类加载器去完成类加载动作。已经违背了双亲委派模型的一般性原则。

**第三次破坏** 是由于用户对程序动态性的追求导致的。这里所说的动态性是指：“代码热替换”、“模块热部署”等等比较热门的词。说白了就是希望应用程序能够像我们的计算机外设一样，接上鼠标、U盘不用重启机器就能立即使用。OSGi是当前业界“事实上”的Java模块化标准，OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现。每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。**在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。**